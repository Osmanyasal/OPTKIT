#pragma once
#include <cstdint>
namespace optkit::arm::neoverse_v3{
	enum neoverse_v3 : uint64_t {
		SW_INCR = 0x00, // Instruction architecturally executed
		L1I_CACHE_REFILL = 0x01, // Level 1 instruction cache refill Counts cache line refills in the level 1 instruction cache caused by a missed instruction fetch
		L1I_TLB_REFILL = 0x02, // Level 1 instruction TLB refill Counts level 1 instruction TLB refills from any Instruction fetch
		L1D_CACHE_REFILL = 0x03, // Level 1 data cache refill Counts level 1 data cache refills caused by speculatively executed load or store operations that missed in the level 1 data cache
		L1D_CACHE = 0x04, // Level 1 data cache access Counts level 1 data cache accesses from any load/store operations
		L1D_TLB_REFILL = 0x05, // Level 1 data TLB refill Counts level 1 data TLB accesses that resulted in TLB refills
		INST_RETIRED = 0x08, // Instruction architecturally executed Counts instructions that have been architecturally executed
		EXC_TAKEN = 0x09, // Exception taken Counts any taken architecturally visible exceptions such as IRQ
		EXC_RETURN = 0x0a, // Instruction architecturally executed
		CID_WRITE_RETIRED = 0x0b, // Instruction architecturally executed
		PC_WRITE_RETIRED = 0x0c, // Instruction architecturally executed
		BR_IMMED_RETIRED = 0x0d, // Branch instruction architecturally executed
		BR_RETURN_RETIRED = 0x0e, // Branch instruction architecturally executed
		BR_MIS_PRED = 0x10, // Branch instruction speculatively executed
		CPU_CYCLES = 0x11, // Cycle Counts CPU clock cycles (not timer cycles)
		BR_PRED = 0x12, // Predictable branch instruction speculatively executed Counts all speculatively executed branches
		MEM_ACCESS = 0x13, // Data memory access Counts memory accesses issued by the CPU load store unit
		L1I_CACHE = 0x14, // Level 1 instruction cache access Counts instruction fetches which access the level 1 instruction cache
		L1D_CACHE_WB = 0x15, // Level 1 data cache write-back Counts write-backs of dirty data from the L1 data cache to the L2 cache
		L2D_CACHE = 0x16, // Level 2 data cache access Counts accesses to the level 2 cache due to data accesses
		L2D_CACHE_REFILL = 0x17, // Level 2 data cache refill Counts cache line refills into the level 2 cache
		L2D_CACHE_WB = 0x18, // Level 2 data cache write-back Counts write-backs of data from the L2 cache to outside the CPU
		BUS_ACCESS = 0x19, // Bus access Counts memory transactions issued by the CPU to the external bus
		MEMORY_ERROR = 0x1a, // Local memory error Counts any detected correctable or uncorrectable physical memory errors (ECC or parity) in protected CPUs RAMs
		INST_SPEC = 0x1b, // Operation speculatively executed Counts operations that have been speculatively executed
		TTBR_WRITE_RETIRED = 0x1c, // Instruction architecturally executed
		BUS_CYCLES = 0x1d, // Bus cycle Counts bus cycles in the CPU
		BR_RETIRED = 0x21, // Instruction architecturally executed
		BR_MIS_PRED_RETIRED = 0x22, // Branch instruction architecturally executed
		STALL_FRONTEND = 0x23, // No operation sent for execution due to the frontend Counts cycles when frontend could not send any micro-operations to the rename stage because of frontend resource stalls caused by fetch memory latency or branch prediction flow stalls
		STALL_BACKEND = 0x24, // No operation sent for execution due to the backend Counts cycles whenever the rename unit is unable to send any micro-operations to the backend of the pipeline because of backend resource constraints
		L1D_TLB = 0x25, // Level 1 data TLB access Counts level 1 data TLB accesses caused by any memory load or store operation
		L1I_TLB = 0x26, // Level 1 instruction TLB access Counts level 1 instruction TLB accesses
		L2D_TLB_REFILL = 0x2d, // Level 2 data TLB refill Counts level 2 TLB refills caused by memory operations from both data and instruction fetch
		L2D_TLB = 0x2f, // Level 2 data TLB access Counts level 2 TLB accesses except those caused by TLB maintenance operations
		REMOTE_ACCESS = 0x31, // Access to another socket in a multi-socket system Counts accesses to another chip
		DTLB_WALK = 0x34, // Data TLB access with at least one translation table walk Counts number of demand data translation table walks caused by a miss in the L2 TLB and performing at least one memory access
		ITLB_WALK = 0x35, // Instruction TLB access with at least one translation table walk Counts number of instruction translation table walks caused by a miss in the L2 TLB and performing at least one memory access
		LL_CACHE_RD = 0x36, // Last level cache access
		LL_CACHE_MISS_RD = 0x37, // Last level cache miss
		L1D_CACHE_LMISS_RD = 0x39, // Level 1 data cache long-latency read miss Counts cache line refills into the level 1 data cache from any memory read operations
		OP_RETIRED = 0x3a, // Micro-operation architecturally executed Counts micro-operations that are architecturally executed
		OP_SPEC = 0x3b, // Micro-operation speculatively executed Counts micro-operations speculatively executed
		STALL = 0x3c, // No operation sent for execution Counts cycles when no operations are sent to the rename unit from the frontend or from the rename unit to the backend for any reason (either frontend or backend stall)
		STALL_SLOT_BACKEND = 0x3d, // No operation sent for execution on a Slot due to the backend Counts slots per cycle in which no operations are sent from the rename unit to the backend due to backend resource constraints
		STALL_SLOT_FRONTEND = 0x3e, // No operation sent for execution on a Slot due to the frontend Counts slots per cycle in which no operations are sent to the rename unit from the frontend due to frontend resource constraints
		STALL_SLOT = 0x3f, // No operation sent for execution on a Slot Counts slots per cycle in which no operations are sent to the rename unit from the frontend or from the rename unit to the backend for any reason (either frontend or backend stall)
		L1D_CACHE_RD = 0x40, // Level 1 data cache access
		L1D_CACHE_WR = 0x41, // Level 1 data cache access
		L1D_CACHE_REFILL_RD = 0x42, // Level 1 data cache refill
		L1D_CACHE_REFILL_WR = 0x43, // Level 1 data cache refill
		L1D_CACHE_REFILL_INNER = 0x44, // Level 1 data cache refill
		L1D_CACHE_REFILL_OUTER = 0x45, // Level 1 data cache refill
		L1D_CACHE_WB_VICTIM = 0x46, // Level 1 data cache write-back
		L1D_CACHE_WB_CLEAN = 0x47, // Level 1 data cache write-back
		L1D_CACHE_INVAL = 0x48, // Level 1 data cache invalidate Counts each explicit invalidation of a cache line in the level 1 data cache caused by: - Cache Maintenance Operations (CMO) that operate by a virtual address
		L1D_TLB_REFILL_RD = 0x4c, // Level 1 data TLB refill
		L1D_TLB_REFILL_WR = 0x4d, // Level 1 data TLB refill
		L1D_TLB_RD = 0x4e, // Level 1 data TLB access
		L1D_TLB_WR = 0x4f, // Level 1 data TLB access
		L2D_CACHE_RD = 0x50, // Level 2 data cache access
		L2D_CACHE_WR = 0x51, // Level 2 data cache access
		L2D_CACHE_REFILL_RD = 0x52, // Level 2 data cache refill
		L2D_CACHE_REFILL_WR = 0x53, // Level 2 data cache refill
		L2D_CACHE_WB_VICTIM = 0x56, // Level 2 data cache write-back
		L2D_CACHE_WB_CLEAN = 0x57, // Level 2 data cache write-back
		L2D_CACHE_INVAL = 0x58, // Level 2 data cache invalidate Counts each explicit invalidation of a cache line in the level 2 cache by cache maintenance operations that operate by a virtual address
		L2D_TLB_REFILL_RD = 0x5c, // Level 2 data TLB refill
		L2D_TLB_REFILL_WR = 0x5d, // Level 2 data TLB refill
		L2D_TLB_RD = 0x5e, // Level 2 data TLB access
		L2D_TLB_WR = 0x5f, // Level 2 data TLB access
		BUS_ACCESS_RD = 0x60, // Bus access
		BUS_ACCESS_WR = 0x61, // Bus access
		MEM_ACCESS_RD = 0x66, // Data memory access
		MEM_ACCESS_WR = 0x67, // Data memory access
		UNALIGNED_LD_SPEC = 0x68, // Unaligned access
		UNALIGNED_ST_SPEC = 0x69, // Unaligned access
		UNALIGNED_LDST_SPEC = 0x6a, // Unaligned access Counts unaligned memory operations issued by the CPU
		LDREX_SPEC = 0x6c, // Exclusive operation speculatively executed
		STREX_PASS_SPEC = 0x6d, // Exclusive operation speculatively executed
		STREX_FAIL_SPEC = 0x6e, // Exclusive operation speculatively executed
		STREX_SPEC = 0x6f, // Exclusive operation speculatively executed
		LD_SPEC = 0x70, // Operation speculatively executed
		ST_SPEC = 0x71, // Operation speculatively executed
		LDST_SPEC = 0x72, // Operation speculatively executed
		DP_SPEC = 0x73, // Operation speculatively executed
		ASE_SPEC = 0x74, // Operation speculatively executed
		VFP_SPEC = 0x75, // Operation speculatively executed
		PC_WRITE_SPEC = 0x76, // Operation speculatively executed
		CRYPTO_SPEC = 0x77, // Operation speculatively executed
		BR_IMMED_SPEC = 0x78, // Branch speculatively executed
		BR_RETURN_SPEC = 0x79, // Branch speculatively executed
		BR_INDIRECT_SPEC = 0x7a, // Branch speculatively executed
		ISB_SPEC = 0x7c, // Barrier speculatively executed
		DSB_SPEC = 0x7d, // Barrier speculatively executed
		DMB_SPEC = 0x7e, // Barrier speculatively executed
		CSDB_SPEC = 0x7f, // Barrier speculatively executed
		EXC_UNDEF = 0x81, // Exception taken
		EXC_SVC = 0x82, // Exception taken
		EXC_PABORT = 0x83, // Exception taken
		EXC_DABORT = 0x84, // Exception taken
		EXC_IRQ = 0x86, // Exception taken
		EXC_FIQ = 0x87, // Exception taken
		EXC_SMC = 0x88, // Exception taken
		EXC_HVC = 0x8a, // Exception taken
		EXC_TRAP_PABORT = 0x8b, // Exception taken
		EXC_TRAP_DABORT = 0x8c, // Exception taken
		EXC_TRAP_OTHER = 0x8d, // Exception taken
		EXC_TRAP_IRQ = 0x8e, // Exception taken
		EXC_TRAP_FIQ = 0x8f, // Exception taken
		RC_LD_SPEC = 0x90, // Release consistency operation speculatively executed
		RC_ST_SPEC = 0x91, // Release consistency operation speculatively executed
		SAMPLE_POP = 0x4000, // Sample Population
		SAMPLE_FEED = 0x4001, // Sample Taken
		SAMPLE_FILTRATE = 0x4002, // Sample Taken and not removed by filtering
		SAMPLE_COLLISION = 0x4003, // Sample collided with previous sample
		CNT_CYCLES = 0x4004, // Constant frequency cycles Increments at a constant frequency equal to the rate of increment of the System Counter
		STALL_BACKEND_MEM = 0x4005, // Memory stall cycles Counts cycles when the backend is stalled because there is a pending demand load request in progress in the last level core cache
		L1I_CACHE_LMISS = 0x4006, // Level 1 instruction cache long-latency miss Counts cache line refills into the level 1 instruction cache
		L2D_CACHE_LMISS_RD = 0x4009, // Level 2 data cache long-latency read miss Counts cache line refills into the level 2 unified cache from any memory read operations that incurred additional latency
		LDST_ALIGN_LAT = 0x4020, // Access with additional latency from alignment Counts the number of memory read and write accesses in a cycle that incurred additional latency
		LD_ALIGN_LAT = 0x4021, // Load with additional latency from alignment Counts the number of memory read accesses in a cycle that incurred additional latency
		ST_ALIGN_LAT = 0x4022, // Store with additional latency from alignment Counts the number of memory write access in a cycle that incurred additional latency
		MEM_ACCESS_CHECKED = 0x4024, // Checked data memory access Counts the number of memory read and write accesses counted by MEM_ACCESS that are tag checked by the Memory Tagging Extension (MTE)
		MEM_ACCESS_CHECKED_RD = 0x4025, // Checked data memory access
		MEM_ACCESS_CHECKED_WR = 0x4026, // Checked data memory access
		SIMD_INST_SPEC = 0x8004, // Operation speculatively executed
		ASE_INST_SPEC = 0x8005, // Operation speculatively executed
		SVE_INST_SPEC = 0x8006, // Operation speculatively executed
		FP_HP_SPEC = 0x8014, // Floating-point operation speculatively executed
		FP_SP_SPEC = 0x8018, // Floating-point operation speculatively executed
		FP_DP_SPEC = 0x801c, // Floating-point operation speculatively executed
		INT_SPEC = 0x8040, // Integer operation speculatively executed Counts speculatively executed integer arithmetic operations
		SVE_PRED_SPEC = 0x8074, // Operation speculatively executed
		SVE_PRED_EMPTY_SPEC = 0x8075, // Operation speculatively executed
		SVE_PRED_FULL_SPEC = 0x8076, // Operation speculatively executed
		SVE_PRED_PARTIAL_SPEC = 0x8077, // Operation speculatively executed
		SVE_PRED_NOT_FULL_SPEC = 0x8079, // SVE predicated operations speculatively executed with no active or partially active predicates Counts speculatively executed predicated SVE operations with at least one non active predicate elements
		PRF_SPEC = 0x8087, // Operation speculatively executed
		SVE_LDFF_SPEC = 0x80bc, // Operation speculatively executed
		SVE_LDFF_FAULT_SPEC = 0x80bd, // Operation speculatively executed
		FP_SCALE_OPS_SPEC = 0x80c0, // Scalable floating-point element ALU operations speculatively executed Counts speculatively executed scalable single precision floating point operations
		FP_FIXED_OPS_SPEC = 0x80c1, // Non-scalable floating-point element ALU operations speculatively executed Counts speculatively executed non-scalable single precision floating point operations
		ASE_SVE_INT8_SPEC = 0x80e3, // Integer operation speculatively executed
		ASE_SVE_INT16_SPEC = 0x80e7, // Integer operation speculatively executed
		ASE_SVE_INT32_SPEC = 0x80eb, // Integer operation speculatively executed
		ASE_SVE_INT64_SPEC = 0x80ef, // Integer operation speculatively executed
		BR_IMMED_TAKEN_RETIRED = 0x8108, // Branch instruction architecturally executed
		BR_INDNR_TAKEN_RETIRED = 0x810c, // Branch instruction architecturally executed
		BR_IMMED_PRED_RETIRED = 0x8110, // Branch instruction architecturally executed
		BR_IMMED_MIS_PRED_RETIRED = 0x8111, // Branch instruction architecturally executed
		BR_IND_PRED_RETIRED = 0x8112, // Branch instruction architecturally executed
		BR_IND_MIS_PRED_RETIRED = 0x8113, // Branch instruction architecturally executed
		BR_RETURN_PRED_RETIRED = 0x8114, // Branch instruction architecturally executed
		BR_RETURN_MIS_PRED_RETIRED = 0x8115, // Branch instruction architecturally executed
		BR_INDNR_PRED_RETIRED = 0x8116, // Branch instruction architecturally executed
		BR_INDNR_MIS_PRED_RETIRED = 0x8117, // Branch instruction architecturally executed
		BR_TAKEN_PRED_RETIRED = 0x8118, // Branch instruction architecturally executed
		BR_TAKEN_MIS_PRED_RETIRED = 0x8119, // Branch instruction architecturally executed
		BR_SKIP_PRED_RETIRED = 0x811a, // Branch instruction architecturally executed
		BR_SKIP_MIS_PRED_RETIRED = 0x811b, // Branch instruction architecturally executed
		BR_PRED_RETIRED = 0x811c, // Branch instruction architecturally executed
		BR_IND_RETIRED = 0x811d, // Instruction architecturally executed
		INST_FETCH_PERCYC = 0x8120, // Event in progress
		MEM_ACCESS_RD_PERCYC = 0x8121, // Event in progress
		INST_FETCH = 0x8124, // Instruction memory access Counts Instruction memory accesses that the PE makes
		DTLB_WALK_PERCYC = 0x8128, // Event in progress
		ITLB_WALK_PERCYC = 0x8129, // Event in progress
		SAMPLE_FEED_BR = 0x812a, // Statisical Profiling sample taken
		SAMPLE_FEED_LD = 0x812b, // Statisical Profiling sample taken
		SAMPLE_FEED_ST = 0x812c, // Statisical Profiling sample taken
		SAMPLE_FEED_OP = 0x812d, // Statisical Profiling sample taken
		SAMPLE_FEED_EVENT = 0x812e, // Statisical Profiling sample taken
		SAMPLE_FEED_LAT = 0x812f, // Statisical Profiling sample taken
		L1D_TLB_RW = 0x8130, // Level 1 data TLB demand access Counts level 1 data TLB demand accesses caused by memory read or write operations
		L1I_TLB_RD = 0x8131, // Level 1 instruction TLB demand access Counts level 1 instruction TLB demand accesses whether the access hits or misses in the TLB
		L1D_TLB_PRFM = 0x8132, // Level 1 data TLB software preload Counts level 1 data TLB accesses generated by software prefetch or preload memory accesses
		L1I_TLB_PRFM = 0x8133, // Level 1 instruction TLB software preload Counts level 1 instruction TLB accesses generated by software preload or prefetch instructions
		DTLB_HWUPD = 0x8134, // Data TLB hardware update of translation table Counts number of memory accesses triggered by a data translation table walk and performing an update of a translation table entry
		ITLB_HWUPD = 0x8135, // Instruction TLB hardware update of translation table Counts number of memory accesses triggered by an instruction translation table walk and performing an update of a translation table entry
		DTLB_STEP = 0x8136, // Data TLB translation table walk
		ITLB_STEP = 0x8137, // Instruction TLB translation table walk
		DTLB_WALK_LARGE = 0x8138, // Data TLB large page translation table walk Counts number of demand data translation table walks caused by a miss in the L2 TLB and yielding a large page
		ITLB_WALK_LARGE = 0x8139, // Instruction TLB large page translation table walk Counts number of instruction translation table walks caused by a miss in the L2 TLB and yielding a large page
		DTLB_WALK_SMALL = 0x813a, // Data TLB small page translation table walk Counts number of data translation table walks caused by a miss in the L2 TLB and yielding a small page
		ITLB_WALK_SMALL = 0x813b, // Instruction TLB small page translation table walk Counts number of instruction translation table walks caused by a miss in the L2 TLB and yielding a small page
		DTLB_WALK_RW = 0x813c, // Data TLB demand access with at least one translation table walk Counts number of demand data translation table walks caused by a miss in the L2 TLB and performing at least one memory access
		ITLB_WALK_RD = 0x813d, // Instruction TLB demand access with at least one translation table walk Counts number of demand instruction translation table walks caused by a miss in the L2 TLB and performing at least one memory access
		DTLB_WALK_PRFM = 0x813e, // Data TLB software preload access with at least one translation table walk Counts number of software prefetches or preloads generated data translation table walks caused by a miss in the L2 TLB and performing at least one memory access
		ITLB_WALK_PRFM = 0x813f, // Instruction TLB software preload access with at least one translation table walk Counts number of software prefetches or preloads generated instruction translation table walks caused by a miss in the L2 TLB and performing at least one memory access
		L1D_CACHE_RW = 0x8140, // Level 1 data cache demand access Counts level 1 data demand cache accesses from any load or store operation
		L1I_CACHE_RD = 0x8141, // Level 1 instruction cache demand fetch Counts demand instruction fetches which access the level 1 instruction cache
		L1D_CACHE_PRFM = 0x8142, // Level 1 data cache software preload Counts level 1 data cache accesses from software preload or prefetch instructions
		L1I_CACHE_PRFM = 0x8143, // Level 1 instruction cache software preload Counts instruction fetches generated by software preload or prefetch instructions which access the level 1 instruction cache
		L1D_CACHE_MISS = 0x8144, // Level 1 data cache demand access miss Counts cache line misses in the level 1 data cache
		L1I_CACHE_HWPRF = 0x8145, // Level 1 instruction cache hardware prefetch Counts instruction fetches which access the level 1 instruction cache generated by the hardware prefetcher
		L1D_CACHE_REFILL_PRFM = 0x8146, // Level 1 data cache refill
		L1I_CACHE_REFILL_PRFM = 0x8147, // Level 1 instruction cache refill
		L2D_CACHE_RW = 0x8148, // Level 2 data cache demand access Counts level 2 cache demand accesses from any load/store operations
		L2D_CACHE_PRFM = 0x814a, // Level 2 data cache software preload Counts level 2 data cache accesses generated by software preload or prefetch instructions
		L2D_CACHE_MISS = 0x814c, // Level 2 data cache demand access miss Counts cache line misses in the level 2 cache
		L2D_CACHE_REFILL_PRFM = 0x814e, // Level 2 data cache refill
		L1D_CACHE_HWPRF = 0x8154, // Level 1 data cache hardware prefetch Counts level 1 data cache accesses from any load/store operations generated by the hardware prefetcher
		L2D_CACHE_HWPRF = 0x8155, // Level 2 data cache hardware prefetch Counts level 2 data cache accesses generated by L2D hardware prefetchers
		STALL_FRONTEND_MEMBOUND = 0x8158, // Frontend stall cycles
		STALL_FRONTEND_L1I = 0x8159, // Frontend stall cycles
		STALL_FRONTEND_MEM = 0x815b, // Frontend stall cycles
		STALL_FRONTEND_TLB = 0x815c, // Frontend stall cycles
		STALL_FRONTEND_CPUBOUND = 0x8160, // Frontend stall cycles
		STALL_FRONTEND_FLOW = 0x8161, // Frontend stall cycles
		STALL_FRONTEND_FLUSH = 0x8162, // Frontend stall cycles
		STALL_BACKEND_MEMBOUND = 0x8164, // Backend stall cycles
		STALL_BACKEND_L1D = 0x8165, // Backend stall cycles
		STALL_BACKEND_L2D = 0x8166, // Backend stall cycles
		STALL_BACKEND_TLB = 0x8167, // Backend stall cycles
		STALL_BACKEND_ST = 0x8168, // Backend stall cycles
		STALL_BACKEND_CPUBOUND = 0x816a, // Backend stall cycles
		STALL_BACKEND_BUSY = 0x816b, // Backend stall cycles
		STALL_BACKEND_ILOCK = 0x816c, // Backend stall cycles
		STALL_BACKEND_RENAME = 0x816d, // Backend stall cycles
		L1I_CACHE_HIT_RD = 0x81c0, // Level 1 instruction cache demand fetch hit Counts demand instruction fetches that access the level 1 instruction cache and hit in the L1 instruction cache
		L1I_CACHE_HIT_RD_FPRFM = 0x81d0, // Level 1 instruction cache demand fetch first hit
		L1I_CACHE_HIT_RD_FHWPRF = 0x81e0, // Level 1 instruction cache demand fetch first hit
		L1I_CACHE_HIT = 0x8200, // Level 1 instruction cache hit Counts instruction fetches that access the level 1 instruction cache and hit in the level 1 instruction cache
		L1I_CACHE_HIT_PRFM = 0x8208, // Level 1 instruction cache software preload hit Counts instruction fetches generated by software preload or prefetch instructions that access the level 1 instruction cache and hit in the level 1 instruction cache
		L1I_LFB_HIT_RD = 0x8240, // Level 1 instruction cache demand fetch line-fill buffer hit Counts demand instruction fetches that access the level 1 instruction cache and hit in a line that is in the process of being loaded into the level 1 instruction cache
		L1I_LFB_HIT_RD_FPRFM = 0x8250, // Level 1 instruction cache demand fetch line-fill buffer first hit
		L1I_LFB_HIT_RD_FHWPRF = 0x8260, // Level 1 instruction cache demand fetch line-fill buffer first hit
		
	};
};

namespace neoverse_v3 = optkit::arm::neoverse_v3;

