#pragma once
#include <cstdint>
namespace optkit::arm::n3{
	enum n3 : uint64_t {
		SW_INCR = 0x00, // Instruction architecturally executed
		L1I_CACHE_REFILL = 0x01, // Level 1 instruction cache refill This event counts any instruction fetch which misses in the cache
		L1I_TLB_REFILL = 0x02, // Level 1 instruction TLB refill This event counts any refill of the L1 instruction TLB from the MMU Translation Cache (MMUTC)
		L1D_CACHE_REFILL = 0x03, // Level 1 data cache refill This event counts any load or store operation or translation table walk that causes data to be read from outside the L1 cache
		L1D_CACHE = 0x04, // Level 1 data cache access This event counts any load or store operation or translation table walk that looks up in the L1 data cache
		L1D_TLB_REFILL = 0x05, // Level 1 data TLB refill This event counts any refill of the data L1 TLB from the L2 TLB
		INST_RETIRED = 0x08, // Instruction architecturally executed This event counts all retired instructions
		EXC_TAKEN = 0x09, // Exception taken The counter counts each exception taken
		EXC_RETURN = 0x0a, // Instruction architecturally executed
		CID_WRITE_RETIRED = 0x0b, // Instruction architecturally executed
		PC_WRITE_RETIRED = 0x0c, // Instruction architecturally executed
		BR_IMMED_RETIRED = 0x0d, // Instruction architecturally executed
		BR_RETURN_RETIRED = 0x0e, // Branch instruction architecturally executed
		BR_MIS_PRED = 0x10, // 
		CPU_CYCLES = 0x11, // Cycle
		BR_PRED = 0x12, // Predictable branch instruction speculatively executed This event counts all predictable branches
		MEM_ACCESS = 0x13, // Data memory access This event counts memory accesses due to load or store instructions
		L1I_CACHE = 0x14, // Level 1 instruction cache access This event counts any instruction fetch which accesses the L1 instruction cache
		L1D_CACHE_WB = 0x15, // Level 1 data cache write-back This event counts any write-back of data from the L1 data cache to lower level of caches
		L2D_CACHE = 0x16, // Level 2 data cache access - If the core is configured with a per-core L2 cache
		L2D_CACHE_REFILL = 0x17, // Level 2 data cache refill - If the core is configured with a per-core L2 cache
		L2D_CACHE_WB = 0x18, // Level 2 data cache write-back If the core is configured with a per-core L2 cache
		BUS_ACCESS = 0x19, // Bus access This event counts for every beat of data that is transferred over the data channels between the core and the SCU
		INST_SPEC = 0x1b, // Operation speculatively executed This event duplicates INST_RETIRED
		TTBR_WRITE_RETIRED = 0x1c, // Instruction architecturally executed
		BUS_CYCLES = 0x1d, // Bus cycle This event duplicates CPU_CYCLES
		L2D_CACHE_ALLOCATE = 0x20, // Level 2 data cache allocation without refill This event counts any full cache line write into the L2 cache which does not cause a linefill
		BR_RETIRED = 0x21, // Branch instruction architecturally executed This event counts all branches
		BR_MIS_PRED_RETIRED = 0x22, // Branch instruction architecturally executed
		STALL_FRONTEND = 0x23, // No operation has been sent for execution
		STALL_BACKEND = 0x24, // No operation has been sent for execution due to the backend
		L1D_TLB = 0x25, // Level 1 data TLB access This event counts any load or store operation which accesses the data L1 TLB
		L1I_TLB = 0x26, // Level 1 instruction TLB access This event counts any instruction fetch which accesses the instruction L1 TLB
		L2I_CACHE = 0x27, // Level 2 instruction cache access The counter counts each instruction memory access to at least the L2 instruction or unified cache
		L2I_CACHE_REFILL = 0x28, // Level 2 instruction cache refill The counter counts each access counted by L2I_CACHE that causes a refill of the L2 instruction or unified cache
		L3D_CACHE_ALLOCATE = 0x29, // Level 3 data cache allocation without refill This event counts any full cache line write into the L3 cache which does not cause a linefill
		L3D_CACHE_REFILL = 0x2a, // Level 3 data cache refill This event counts for any cacheable read transaction returning data from the SCU for which the data source was outside the cluster
		L3D_CACHE = 0x2b, // Level 3 data cache access This event counts for any cacheable read
		L2D_TLB_REFILL = 0x2d, // Level 2 data TLB refill This event counts on any refill of the L2 TLB
		L2D_TLB = 0x2f, // Level 2 data TLB access Attributable level 2 unified TLB access
		REMOTE_ACCESS = 0x31, // Access to another socket in a multi-socket system This event counts any transactions returning data from another socket in a multi-socket system
		LL_CACHE = 0x32, // Last level cache access The counter counts each memory-read operation or memory-write operation that causes a cache access to at least the last level cache
		LL_CACHE_MISS = 0x33, // Last level cache miss The counter counts each access counted by LL_CACHE that is not completed by the last level cache
		DTLB_WALK = 0x34, // Data TLB access with at least one translation table walk Access to data TLB that caused a translation table walk
		ITLB_WALK = 0x35, // Instruction TLB access with at least one translation table walk Access to instruction TLB that caused a translation table walk
		LL_CACHE_RD = 0x36, // Last level cache access
		LL_CACHE_MISS_RD = 0x37, // Last Level cache miss read This event counts any cacheable read transaction which returns a data source of 'DRAM'
		L1D_CACHE_LMISS_RD = 0x39, // Level 1 data cache long-latency read miss Level 1 data cache access
		OP_RETIRED = 0x3a, // This event counts each operation counted by OP_SPEC that would be executed in a Simple sequential execution of the program
		OP_SPEC = 0x3b, // Micro-operation speculatively executed This event counts the number of operations executed by the core
		STALL = 0x3c, // No operation sent for execution This event counts every Attributable cycle on which no Attributable instruction or operation was sent for execution on this core
		STALL_SLOT_BACKEND = 0x3d, // No operation sent for execution on a Slot due to the backend Counts each Slot counted by STALL_SLOT where no Attributable instruction or operation was for execution because the backend is unable to accept one of: - The instruction operation available for the PE on the slot
		STALL_SLOT_FRONTEND = 0x3e, // No operation sent for execution due to the frontend
		STALL_SLOT = 0x3f, // No operation sent for execution on a Slot The counter counts on each Attributable cycle the number of instruction or operation Slots that were not occupied by an instruction or operation Attributable to the PE
		L1D_CACHE_RD = 0x40, // Level 1 data cache access
		L1D_CACHE_WR = 0x41, // Level 1 data cache access
		L1D_CACHE_REFILL_INNER = 0x44, // Level 1 data cache refill
		L1D_CACHE_REFILL_OUTER = 0x45, // Level 1 data cache refill
		L1D_CACHE_INVAL = 0x48, // Level 1 data cache invalidate The counter counts each invalidation of a cache line in the Level 1 data or unified cache
		L2D_CACHE_RD = 0x50, // Level 2 data cache access
		L2D_CACHE_WR = 0x51, // Level 2 data cache access
		L2D_CACHE_REFILL_RD = 0x52, // Level 2 data cache refill
		L2D_CACHE_REFILL_WR = 0x53, // Level 2 data cache refill
		L2D_CACHE_WB_VICTIM = 0x56, // Level 2 data cache write-back
		L2D_CACHE_WB_CLEAN = 0x57, // Level 2 data cache write-back
		L2D_CACHE_INVAL = 0x58, // Level 2 data cache invalidate This event counts any cache maintenance operation which causes the invalidation of a line present in the L2 cache
		BUS_ACCESS_RD = 0x60, // Bus access
		BUS_ACCESS_WR = 0x61, // Bus access
		MEM_ACCESS_RD = 0x66, // Data memory access
		MEM_ACCESS_WR = 0x67, // Data memory access
		STREX_FAIL_SPEC = 0x6e, // Exclusive operation speculatively executed
		STREX_SPEC = 0x6f, // Exclusive operation speculatively executed
		LD_SPEC = 0x70, // Operation speculatively executed
		ST_SPEC = 0x71, // Operation speculatively executed
		DP_SPEC = 0x73, // Operation speculatively executed
		ASE_SPEC = 0x74, // Operation speculatively executed
		VFP_SPEC = 0x75, // Operation speculatively executed
		PC_WRITE_SPEC = 0x76, // Operation speculatively executed
		CRYPTO_SPEC = 0x77, // Operation speculatively executed
		ISB_SPEC = 0x7c, // Barrier speculatively executed
		DSB_SPEC = 0x7d, // Barrier speculatively executed
		DMB_SPEC = 0x7e, // Barrier speculatively executed
		EXC_UNDEF = 0x81, // Exception taken
		EXC_SVC = 0x82, // Exception taken
		EXC_PABORT = 0x83, // Exception taken
		EXC_DABORT = 0x84, // Exception taken
		EXC_IRQ = 0x86, // Exception taken
		EXC_FIQ = 0x87, // Exception taken
		EXC_SMC = 0x88, // Exception taken
		EXC_HVC = 0x8a, // Exception taken
		EXC_TRAP_PABORT = 0x8b, // Exception taken
		EXC_TRAP_DABORT = 0x8c, // Exception taken
		EXC_TRAP_OTHER = 0x8d, // Exception taken
		EXC_TRAP_IRQ = 0x8e, // Exception taken
		EXC_TRAP_FIQ = 0x8f, // Exception taken
		RC_LD_SPEC = 0x90, // Release consistency operation speculatively executed
		RC_ST_SPEC = 0x91, // Release consistency operation speculatively executed
		L3D_CACHE_RD = 0xa0, // Level 3 data cache access
		SAMPLE_POP = 0x4000, // Sample Population
		SAMPLE_FEED = 0x4001, // Sample Taken
		SAMPLE_FILTRATE = 0x4002, // Sample Taken and not removed by filtering
		SAMPLE_COLLISION = 0x4003, // Sample collided with previous sample
		CNT_CYCLES = 0x4004, // Constant frequency cycles The counter increments at a constant frequency equal to the rate of increment of the System Counter
		STALL_BACKEND_MEM = 0x4005, // Memory stall cycles The counter counts each cycle counted by STALL_BACKEND_MEMBOUND where there is a demand data miss in the last level of data or unified cache within the PE clock domain or a non-cacheable data access in progress
		L1I_CACHE_LMISS = 0x4006, // Level 1 instruction cache long-latency miss The counter counts each access counted by L1I_CACHE that incurs additional latency because it returns instructions from outside the L1 instruction cache
		L2D_CACHE_LMISS_RD = 0x4009, // Level 2 data cache long-latency read miss The counter counts each memory read access counted by L2D_CACHE that incurs additional latency because it returns data from outside the L2 data or unified cache of this PE
		L2I_CACHE_LMISS = 0x400a, // Level 2 instruction cache long-latency miss The counter counts each memory read access counted by L2I_CACHE that incurs additional latency because it returns data from outside the L2 instruction or unified cache of this PE
		L3D_CACHE_LMISS_RD = 0x400b, // Level 3 data cache long-latency read miss The counter counts each memory read access counted by L3D_CACHE that incurs additional latency because it returns data from outside the L3 data or unified cache of this PE
		TRB_WRAP = 0x400c, // Trace buffer current write pointer wrapped
		PMU_OVFS = 0x400d, // PMU overflow
		TRB_TRIG = 0x400e, // Trace buffer Trigger Event Note: This event is only exported to the trace unit and is not visible to the PMU
		PMU_HOVFS = 0x400f, // PMU overflow
		TRCEXTOUT0 = 0x4010, // Trace unit external output 0 PE Trace Unit external output 0 Note: This event is not exported to the trace unit
		TRCEXTOUT1 = 0x4011, // Trace unit external output 1 PE Trace Unit external output 1 Note: This event is not exported to the trace unit
		TRCEXTOUT2 = 0x4012, // Trace unit external output 2 PE Trace Unit external output 2 Note: This event is not exported to the trace unit
		TRCEXTOUT3 = 0x4013, // Trace unit external output 3 PE Trace Unit external output 3 Note: This event is not exported to the trace unit
		CTI_TRIGOUT4 = 0x4018, // Cross Trigger Interface output trigger 4
		CTI_TRIGOUT5 = 0x4019, // Cross Trigger Interface output trigger 5
		CTI_TRIGOUT6 = 0x401a, // Cross Trigger Interface output trigger 6
		CTI_TRIGOUT7 = 0x401b, // Cross Trigger Interface output trigger 7
		LDST_ALIGN_LAT = 0x4020, // Access with additional latency from alignment The counter counts each access counted by MEM_ACCESS that
		LD_ALIGN_LAT = 0x4021, // Load with additional latency from alignment The counter counts each memory-read access counted by LDST_ALIGN_LAT
		ST_ALIGN_LAT = 0x4022, // Store with additional latency from alignment The counter counts each memory-write access counted by LDST_ALIGN_LAT
		MEM_ACCESS_CHECKED = 0x4024, // Checked data memory access
		MEM_ACCESS_CHECKED_RD = 0x4025, // Checked data memory access
		MEM_ACCESS_CHECKED_WR = 0x4026, // Checked data memory access
		ASE_INST_SPEC = 0x8005, // Advanced SIMD operations speculatively executed
		SVE_INST_SPEC = 0x8006, // SVE operation
		FP_HP_SPEC = 0x8014, // Half-precision floating-point operation speculatively executed
		FP_SP_SPEC = 0x8018, // Single-precision floating-point operation speculatively executed
		FP_DP_SPEC = 0x801c, // Double-precision floating-point operation speculatively executed
		SVE_PRED_SPEC = 0x8074, // SVE predicated operations speculatively executed
		SVE_PRED_EMPTY_SPEC = 0x8075, // SVE predicated operations with no active predicates speculatively executed
		SVE_PRED_FULL_SPEC = 0x8076, // SVE predicated operations with all active predicates speculatively executed
		SVE_PRED_PARTIAL_SPEC = 0x8077, // SVE predicated operations with partially active predicates speculatively executed
		SVE_PRED_NOT_FULL_SPEC = 0x8079, // SVE predicated operations with no or partially active predicates speculatively executed
		SVE_LDFF_SPEC = 0x80bc, // SVE First-fault load operations speculatively executed
		SVE_LDFF_FAULT_SPEC = 0x80bd, // SVE First-fault load operations speculatively executed which set FFR bit to 0
		FP_SCALE_OPS_SPEC = 0x80c0, // Scalable floating-point element operations speculatively executed
		FP_FIXED_OPS_SPEC = 0x80c1, // Non-scalable floating-point element operations speculatively executed
		ASE_SVE_INT8_SPEC = 0x80e3, // Advanced SIMD and SVE 8-bit integer operation speculatively executed
		ASE_SVE_INT16_SPEC = 0x80e7, // Advanced SIMD and SVE 16-bit integer operation speculatively executed
		ASE_SVE_INT32_SPEC = 0x80eb, // Advanced SIMD and SVE 32-bit integer operation speculatively executed
		ASE_SVE_INT64_SPEC = 0x80ef, // Advanced SIMD and SVE 64-bit integer operation speculatively executed
		BR_IMMED_TAKEN_RETIRED = 0x8108, // Instruction architecturally executed
		BR_INDNR_TAKEN_RETIRED = 0x810c, // Instruction architecturally executed
		BR_IMMED_PRED_RETIRED = 0x8110, // Branch instruction architecturally executed
		BR_IMMED_MIS_PRED_RETIRED = 0x8111, // Branch instruction architecturally executed
		BR_IND_PRED_RETIRED = 0x8112, // Branch instruction architecturally executed
		BR_IND_MIS_PRED_RETIRED = 0x8113, // Branch instruction architecturally executed
		BR_RETURN_PRED_RETIRED = 0x8114, // Branch instruction architecturally executed
		BR_RETURN_MIS_PRED_RETIRED = 0x8115, // Branch instruction architecturally executed
		BR_INDNR_PRED_RETIRED = 0x8116, // Branch instruction architecturally executed
		BR_INDNR_MIS_PRED_RETIRED = 0x8117, // Branch instruction architecturally executed
		BR_PRED_RETIRED = 0x811c, // Branch instruction architecturally executed
		BR_IND_RETIRED = 0x811d, // Instruction architecturally executed
		INST_FETCH_PERCYC = 0x8120, // Event in progress
		MEM_ACCESS_RD_PERCYC = 0x8121, // Event in progress
		INST_FETCH = 0x8124, // Instruction memory access The counter counts each Instruction memory access that the PE makes
		DTLB_WALK_PERCYC = 0x8128, // Total cycles
		ITLB_WALK_PERCYC = 0x8129, // Total cycles
		SAMPLE_FEED_BR = 0x812a, // Statistical Profiling sample taken
		SAMPLE_FEED_LD = 0x812b, // Statistical Profiling sample taken
		SAMPLE_FEED_ST = 0x812c, // Statistical Profiling sample taken
		SAMPLE_FEED_OP = 0x812d, // Statistical Profiling sample taken
		SAMPLE_FEED_EVENT = 0x812e, // Statistical Profiling sample taken
		SAMPLE_FEED_LAT = 0x812f, // Statistical Profiling sample taken
		DTLB_HWUPD = 0x8134, // Data TLB hardware update of translation table The counter counts each access counted by L1D_TLB that causes a hardware update of a translation table entry
		ITLB_HWUPD = 0x8135, // Instruction TLB hardware update of translation table The counter counts each access counted by L1I_TLB that causes a hardware update of a translation table entry
		DTLB_STEP = 0x8136, // Data TLB translation table walk
		ITLB_STEP = 0x8137, // Instruction TLB translation table walk
		DTLB_WALK_LARGE = 0x8138, // Data TLB large page translation table walk The counter counts each translation table walk counted by DTLB_WALK where the result of the walk yields a large page size
		ITLB_WALK_LARGE = 0x8139, // Instruction TLB large page translation table walk The counter counts each translation table walk counted by ITLB_WALK where the result of the walk yields a large page size
		DTLB_WALK_SMALL = 0x813a, // Data TLB small page translation table walk The counter counts each translation table walk counted by DTLB_WALK where the result of the walk yields a small page size
		ITLB_WALK_SMALL = 0x813b, // Instruction TLB small page translation table walk The counter counts each translation table walk counted by ITLB_WALK where the result of the walk yields a small page size
		L1D_CACHE_RW = 0x8140, // Level 1 data cache demand access The counter counts each access counted by L1D_CACHE that is due to a demand read or demand write access
		L2D_CACHE_RW = 0x8148, // Level 2 data cache demand access The counter counts each access counted by L2D_CACHE that is due to a demand Memoryread operation or demand Memory-write operation
		L2I_CACHE_RD = 0x8149, // Level 2 instruction cache demand fetch The counter counts each access counted by L2I_CACHE that is due to a demand instruction memory access
		L3D_CACHE_MISS = 0x8152, // Level 3 data cache demand access miss The counter counts each access counted by L3D_CACHE_RW that misses in the L1 to L3 data or unified caches
		L1D_CACHE_HWPRF = 0x8154, // Level 1 data cache hardware prefetch The counter counts each fetch triggered by L1 prefetchers
		STALL_FRONTEND_MEMBOUND = 0x8158, // Frontend stall cycles
		STALL_FRONTEND_L1I = 0x8159, // Frontend stall cycles
		STALL_FRONTEND_MEM = 0x815b, // Frontend stall cycles
		STALL_FRONTEND_TLB = 0x815c, // Frontend stall cycles
		STALL_FRONTEND_CPUBOUND = 0x8160, // Frontend stall cycles
		STALL_FRONTEND_FLUSH = 0x8162, // Frontend stall cycles
		STALL_BACKEND_MEMBOUND = 0x8164, // Backend stall cycles
		STALL_BACKEND_L1D = 0x8165, // Backend stall cycles
		STALL_BACKEND_TLB = 0x8167, // Backend stall cycles
		STALL_BACKEND_ST = 0x8168, // Back stall cycles store The counter counts each cycle counted by STALL_BACKEND_MEMBOUND when the backend is stalled waiting for a store
		STALL_BACKEND_CPUBOUND = 0x816a, // Backend stall cycles
		STALL_BACKEND_BUSY = 0x816b, // Backend stall cycles
		STALL_BACKEND_RENAME = 0x816d, // Backend stall cycles
		CAS_NEAR_PASS = 0x8171, // Atomic memory Operation speculatively executed
		CAS_NEAR_SPEC = 0x8172, // Atomic memory Operation speculatively executed
		CAS_FAR_SPEC = 0x8173, // Atomic memory Operation speculatively executed
		L1D_CACHE_REFILL_HWPRF = 0x81bc, // Level 1 data cache refill
		L2D_CACHE_PRF = 0x8285, // Level 2 data cache
		L2D_CACHE_REFILL_PRF = 0x828d, // Level 2 data cache refill
		LL_CACHE_REFILL = 0x829a, // Last level cache refill The counter counts each access counted by LL_CACHE that causes a refill of the Last level cache
		
	};
};

namespace n3 = optkit::arm::n3;

